package key_events

import (
	"log"
	"runtime"
	"time"

	"github.com/SirGFM/midi-go-key/err_wrap"
	"github.com/SirGFM/midi-go-key/midi"
	"github.com/micmonay/keybd_event"
)

// How many timed actions may be queued at once.
const timedActionQueueSize = 64

type KeyEvents interface {
	// Releases every resource associated with the key events generator
	Close() error

	// RegisterBasicPressAction registers the most basic action of pressing and
	// shortly thereafter (after releaseTime) releasing it.
	RegisterBasicPressAction(
		evType midi.MidiEventType,
		channel,
		key uint8,
		keyCode int,
		releaseTime time.Duration,
	)

	// RegisterVelocityAction registers the action of pressing a key
	// based on the velocity of the MIDI event.
	// The greater the velocity, the closer to maxPress that the key is held down.
	RegisterVelocityAction(
		evType midi.MidiEventType,
		channel,
		key uint8,
		keyCode int,
		minPress,
		maxPress time.Duration,
	)

	// RegisterToggleAction registers an action that toggles a key whenever
	// the MIDI event is generated.
	// To send quick presses, set a velocity threshold,
	// bellow which the action will be executed regularly, instead of toggling.
	// This also causes the toggle to get released, if it were pressed.
	RegisterToggleAction(
		evType midi.MidiEventType,
		channel,
		key uint8,
		keyCode int,
		threshold uint8,
		quickPressDuration time.Duration,
	)

	// RegisterHoldAction registers an actions that stays pressed
	// as long as the MIDI event is repeated.
	// If the MIDI event hasn't been sent in maxRepeatDelayMs,
	// then the key will be released after shortRelease.
	// Otherwise, it will stay pressed for maxRepeatDelayMs
	// of the last event.
	RegisterHoldAction(
		evType midi.MidiEventType,
		channel,
		key uint8,
		keyCode int,
		maxRepeatDelayMs int32,
		shortRelease time.Duration,
	)

	// ReadConfig reads the configuration file in path and registers the listed actions.
	ReadConfig(path string) error
}

// A MIDI event generated for a given note,
// ignoring it's velocity.
type noteEvent [2]byte

// An timerAction generated by a timer.
type timerAction func()

type keyEvents struct {
	// The internal key events generator.
	kb *keybd_event.KeyBonding
	// The channel used to receive MIDI events.
	conn <-chan midi.MidiEvent
	// List actions taken in response to the registered actions.
	actions map[noteEvent]*midiAction
	// Receive actions that should be generated based on a timer.
	timedAction chan timerAction
	// Whether unhandled events should be logged.
	logUnhandled bool
}

// NewKeyEvents creates and starts a new event generator.
// When conn is closed, the key event generator stops running.
func NewKeyEvents(conn <-chan midi.MidiEvent, logUnhandled bool) (KeyEvents, error) {
	kb, err := keybd_event.NewKeyBonding()
	if err != nil {
		return nil, err_wrap.Wrap(err, ErrGetKeyGenerator)
	}

	// For linux, it is very important to wait 2 seconds
	if runtime.GOOS == "linux" {
		time.Sleep(2 * time.Second)
	}

	kbEv := &keyEvents{
		kb:           &kb,
		conn:         conn,
		actions:      make(map[noteEvent]*midiAction),
		timedAction:  make(chan timerAction, timedActionQueueSize),
		logUnhandled: logUnhandled,
	}
	go kbEv.run()

	return kbEv, nil
}

func (kbEv *keyEvents) Close() error {
	return nil
}

// run listens for MIDI events and generates key events.
func (kbEv *keyEvents) run() {
	for {
		select {
		case midiEv, hasMore := <-kbEv.conn:
			if !hasMore {
				return
			}
			kbEv.handleMidiEvent(midiEv)
		case action := <-kbEv.timedAction:
			// timedAction are queued as a response to MIDI events,
			// so just execute them as they are received.
			action()
		}
	}
}

// handleMidiEvent handles a given MIDI event,
// executing its registered action.
func (kbEv *keyEvents) handleMidiEvent(midiEv midi.MidiEvent) {
	var event noteEvent

	if len(midiEv.Source) < len(event) {
		log.Printf("invalid event received: %s\n", midiEv)
		return
	}
	copy(event[:], midiEv.Source)

	if action, ok := kbEv.actions[event]; ok {
		action.action(midiEv)
	} else if kbEv.logUnhandled {
		log.Printf("unhandled: %s\n", midiEv)
	}
}

// generateNoteEvent generates noteEvent from the desired parameters.
func generateNoteEvent(evType midi.MidiEventType, channel, key uint8) noteEvent {
	var event noteEvent

	event[0] = evType.ToUint8() | channel
	event[1] = key

	return event
}

// removeAction removes an action associated with the give event, if any.
func (kbEv *keyEvents) removeAction(event noteEvent) {
	if action, ok := kbEv.actions[event]; ok {
		action.Close()
		delete(kbEv.actions, event)
	}
}

func (kbEv *keyEvents) RegisterBasicPressAction(
	evType midi.MidiEventType,
	channel,
	key uint8,
	keyCode int,
	releaseTime time.Duration,
) {

	event := generateNoteEvent(evType, channel, key)

	kbEv.removeAction(event)

	// Create a new action handler and start its timer.
	handler := newMidiAction()

	// Register the onPress function.
	handler.action = func(ev midi.MidiEvent) {
		if ev.Type != midi.EventNoteOn || ev.Velocity == 0 {
			return
		}

		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Press()

		handler.QueueTimedAction(releaseTime)
	}

	// Register the onRelease function,
	// automatically queued after releaseTime from the press.
	handler.onTimeout = func() {
		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Release()
	}

	kbEv.actions[event] = handler
}

//	- ex: hit drum pedal -> press up key based on the velocity
func (kbEv *keyEvents) RegisterVelocityAction(
	evType midi.MidiEventType,
	channel,
	key uint8,
	keyCode int,
	minPress,
	maxPress time.Duration,
) {
	event := generateNoteEvent(evType, channel, key)

	kbEv.removeAction(event)

	// Create a new action handler and start its timer.
	handler := newMidiAction()

	// Stores the key state between the functions.
	isPressed := false

	// Register the onPress function.
	handler.action = func(ev midi.MidiEvent) {
		if ev.Type != midi.EventNoteOn || ev.Velocity == 0 {
			return
		}

		if ev.Velocity > midi.MaxVelocity {
			log.Printf("max velocity was reached! %d\n", ev.Velocity)
		}

		// Calculate how long the key should be pressed based on the key velocity.
		releaseTime := maxPress - minPress
		releaseTime *= time.Duration(ev.Velocity)
		releaseTime /= midi.MaxVelocity
		releaseTime += minPress

		onPress := func() {
			kbEv.kb.SetKeys(keyCode)
			kbEv.kb.Press()

			isPressed = true

			handler.QueueTimedAction(releaseTime)
		}

		if isPressed {
			// If the key was already pressed,
			// release it momentarily and then press it again.
			kbEv.kb.SetKeys(keyCode)
			kbEv.kb.Release()

			go func() {
				time.Sleep(time.Millisecond)
				onPress()
			}()
		} else {
			onPress()
		}
	}

	// Register the onRelease function,
	// automatically queued after releaseTime from the press.
	handler.onTimeout = func() {
		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Release()
		isPressed = false
	}

	kbEv.actions[event] = handler
}

func (kbEv *keyEvents) RegisterToggleAction(
	evType midi.MidiEventType,
	channel,
	key uint8,
	keyCode int,
	threshold uint8,
	quickPressDuration time.Duration,
) {
	event := generateNoteEvent(evType, channel, key)

	kbEv.removeAction(event)

	// Create a new action handler and start its timer.
	handler := newMidiAction()

	// Stores the key state between the functions.
	isPressed := false

	// Register the onPress function.
	handler.action = func(ev midi.MidiEvent) {
		if ev.Type != midi.EventNoteOn || ev.Velocity == 0 {
			return
		}

		if isPressed {
			// If it is pressed, simply release it.
			kbEv.kb.SetKeys(keyCode)
			kbEv.kb.Release()

			isPressed = false
			handler.UnqueueTimedAction()
		} else {
			// Otherwise, simply toggle it on.
			kbEv.kb.SetKeys(keyCode)
			kbEv.kb.Press()

			isPressed = true

			// If the hit was bellow the threshold,
			// simply do a quick press.
			if ev.Velocity < threshold {
				handler.QueueTimedAction(quickPressDuration)
			}
		}
	}

	// Register the onRelease function,
	// automatically queued after releaseTime from a press bellow the threshold.
	handler.onTimeout = func() {
		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Release()
		isPressed = false
	}

	kbEv.actions[event] = handler
}

func (kbEv *keyEvents) RegisterHoldAction(
	evType midi.MidiEventType,
	channel,
	key uint8,
	keyCode int,
	maxRepeatDelayMs int32,
	shortRelease time.Duration,
) {
	event := generateNoteEvent(evType, channel, key)

	kbEv.removeAction(event)

	// Create a new action handler and start its timer.
	handler := newMidiAction()

	// Stores the last time the MIDI event was received.
	var lastTimestamp int32

	// Register the onPress function.
	handler.action = func(ev midi.MidiEvent) {
		if ev.Type != midi.EventNoteOn || ev.Velocity == 0 {
			return
		}

		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Press()

		// If the event was sent quickly enough,
		// requeue the action for a longer time.
		// Otherwise, simply send a quick action.
		if ev.Timestamp-lastTimestamp > maxRepeatDelayMs {
			handler.QueueTimedAction(shortRelease)
		} else {
			handler.QueueTimedAction(time.Duration(maxRepeatDelayMs) * time.Millisecond)
		}

		lastTimestamp = ev.Timestamp
	}

	// Register the onRelease function,
	// automatically queued after releaseTime from the press.
	handler.onTimeout = func() {
		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Release()
	}

	kbEv.actions[event] = handler
}

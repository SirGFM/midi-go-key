package key_events

import (
	"fmt"
	"runtime"
	"time"

	"github.com/SirGFM/midi-go-key/err_wrap"
	"github.com/SirGFM/midi-go-key/midi"
	"github.com/micmonay/keybd_event"
)

// How many timed actions may be queued at once.
const timedActionQueueSize = 64

type KeyEvents interface {
	// Releases every resource associated with the key events generator
	Close() error

	// RegisterBasicPressAction registers the most basic action of pressing and
	// shortly thereafter (after releaseTime) releasing it.
	RegisterBasicPressAction(
		evType midi.MidiEventType,
		channel,
		key uint8,
		keyCode int,
		releaseTime time.Duration,
	)
}

// A MIDI event generated for a given note,
// ignoring it's velocity.
type noteEvent [2]byte

// An timerAction generated by a timer.
type timerAction func()

type keyEvents struct {
	// The internal key events generator.
	kb *keybd_event.KeyBonding
	// The channel used to receive MIDI events.
	conn <-chan midi.MidiEvent
	// List actions taken in response to the registered actions.
	actions map[noteEvent]*midiAction
	// Receive actions that should be generated based on a timer.
	timedAction chan timerAction
}

// NewKeyEvents creates and starts a new event generator.
// When conn is closed, the key event generator stops running.
func NewKeyEvents(conn <-chan midi.MidiEvent) (KeyEvents, error) {
	kb, err := keybd_event.NewKeyBonding()
	if err != nil {
		return nil, err_wrap.Wrap(err, ErrGetKeyGenerator)
	}

	// For linux, it is very important to wait 2 seconds
	if runtime.GOOS == "linux" {
		time.Sleep(2 * time.Second)
	}

	kbEv := &keyEvents{
		kb:      &kb,
		conn:    conn,
		actions: make(map[noteEvent]*midiAction),
		timedAction: make(chan timerAction, timedActionQueueSize),
	}
	go kbEv.run()

	return kbEv, nil
}

func (kbEv *keyEvents) Close() error {
	return nil
}

// run listens for MIDI events and generates key events.
func (kbEv *keyEvents) run() {
	for {
		select {
		case midiEv, hasMore := <-kbEv.conn:
			if !hasMore {
				return
			}
			kbEv.handleMidiEvent(midiEv)
		case action := <-kbEv.timedAction:
			// timedAction are queued as a response to MIDI events,
			// so just execute them as they are received.
			action()
		}
	}
}

// handleMidiEvent handles a given MIDI event,
// executing its registered action.
func (kbEv *keyEvents) handleMidiEvent(midiEv midi.MidiEvent) {
	var event noteEvent

	if len(midiEv.Source) < len(event) {
		fmt.Printf("(key_events): Invalid event received: %s\n", midiEv)
		return
	}
	copy(event[:], midiEv.Source)

	if action, ok := kbEv.actions[event]; ok {
		action.action(midiEv)
	}
}

// generateNoteEvent generates noteEvent from the desired parameters.
func generateNoteEvent(evType midi.MidiEventType, channel, key uint8) noteEvent {
	var event noteEvent

	event[0] = evType.ToUint8() | channel
	event[1] = key

	return event
}

// removeAction removes an action associated with the give event, if any.
func (kbEv *keyEvents) removeAction(event noteEvent) {
	if action, ok := kbEv.actions[event]; ok {
		action.Close()
		delete(kbEv.actions, event)
	}
}

func (kbEv *keyEvents) RegisterBasicPressAction(
	evType midi.MidiEventType,
	channel,
	key uint8,
	keyCode int,
	releaseTime time.Duration,
) {

	event := generateNoteEvent(evType, channel, key)

	kbEv.removeAction(event)

	// Create a new action handler and start its timer.
	handler := newMidiAction()

	// Register the onPress function.
	handler.action = func(ev midi.MidiEvent) {
		if ev.Type != midi.EventNoteOn || ev.Velocity == 0 {
			return
		}

		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Press()

		handler.QueueTimedAction(releaseTime)
	}

	// Register the onRelease function,
	// automatically queued after releaseTime from the press.
	handler.onTimeout = func() {
		kbEv.kb.SetKeys(keyCode)
		kbEv.kb.Release()
	}

	kbEv.actions[event] = handler
}
